Универсальное хэширование и идеальная хэш-функция
При разработке систем хэширования довольно часто применяется понятие "противник". Это своеобразный оппонент, который всячески пытается помешать работе нашей хэш-системы. Например, если он знает устройство хэш-функции, то может подобрать такой входной набор данных, который быстро приведёт к экстремальному числу коллизий и выведет всю систему из строя.

1. Универсальное хэширование

Противодействовать противнику призвана концепция универсального хэширования. Она подразумевает, что выбор хэш-функции происходит случайно, из некоторого семейства таких функций, поэтому в среднем мы получим некоторую удовлетворительную производительность независимо от любых действий противника. Только для этого необходимо, чтобы хэш-функции были независимы (попарно), то есть для любой пары хэш-функций надо, чтобы вероятность коллизий по выданным ими индексам для двух разных ключей не превышала 1 / длина таблицы.

Если для разрешения коллизий использовать цепочки, то какой примерно следует ожидать их длину? От этого зависит ряд практических методов их реализации в виде списков или других типов данных.

Доказано, что при случайном выборе хэш-функции из семейства средняя длина списка будет равна

1 + S / m
где S -- это количество отображённых в таблицу ключей, а m -- длина таблицы.

То есть, когда в таблицу поступило количество элементов, равное её длине, считаем, что средняя длина цепочки -- два элемента.

2. Универсальное семейство хэш-функций

Как строить универсальное семейство хэш-функций? Доказано, что если входные данные целочисленные, то в такое семейство достаточно включать функции вида

h(x) = ((ax + b) mod p) mod m
где p -- простое число, a и b -- коэффициенты в целом диапазоне от 1 до p-1 и от 0 до p-1 соответственно, а m -- длина таблицы.

Сколько хэш-функций требуется для универсального семейства? Когда есть "противник", то чем больше, тем лучше, ведь тем сложнее ему будет угадать.

Схем реализаций здесь три:
1) конкретная хэш-функция выбирается случайно и однократно на весь этап работы с таблицей. Плюс в простоте, минус что мы как раз и хотим уйти от использования одной функции;
2) хэш-функции периодически меняются на лету. Минус в том, что при смене хэш-функции надо выполнить объёмную перестройку всей таблицы под новую схему генерации индексов по ключам;
3) хэш-функции меняются, когда количество коллизий существенно превышает планируемое.

3. Совершенная хэш-функция

В идеале, конечно, хотелось бы иметь идеальную, или совершенную хэш-функцию, которая вообще без коллизий распределяет значения по таблице за O(1). Такую функцию однако вполне реально получить, если мы точно знаем множество входных значений и уверены, что оно не меняется. Для этого требуются два шага, рассмотрим их на примере целочисленных ключей.

1) выбираем произвольную хэш-функцию h() из универсального семейства;
2) чтобы обработать её возможные коллизии, для каждого i-го слота таблицы формируем дополнительную хэш-таблицу, для которой будет использоваться собственная хэш-функция hi(). На данном этапе уже можно гарантировать отсутствие коллизий, так как мы знаем подмножество входных значений, которые попадают в i-й слот -- достаточно задать размер данной таблицы равному квадрату от количества элементов, на которых сработает коллизия для h(). Только функцию hi() потребуется дополнительно настроить, а если ещё оттюнинговать и h(), то размер дополнительной таблицы можно уменьшить до размера исходной.