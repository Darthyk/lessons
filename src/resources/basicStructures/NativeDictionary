Ассоциативный массив
Хэш-таблицы хоть и реализованы в большинстве языков программирования, в стандартных библиотеках, однако напрямую используются редко, так как сами по себе не очень полезны. Однако существует такая очень популярная структура данных, как ассоциативный массив (или словарь), когда мы храним данные в формате ключ - значение. Такой массив отличается от обычного тем, что в качестве индексов выступают не целые числа, а произвольные значения (например, строки). Вот тут мы и находим точку пересечения с хэш-таблицами.

Практически во всех современных языках присутствует структура данных Словарь (Dictionary, Map, ...). Он позволяет поместить в переменную набор пар ключ-значение.

Часто при записи поддерживается синтаксис формата данных JSON, например:

my_dict = {"key1": "значение 1", "ключ 23": 512}
и в дальнейшем получать нужное значение, указав ключ в качестве индекса:

my_dict["ключ 23"]
Можно изменять значения в словаре:

my_dict["ключ 23"] = 1024
Для реализации ассоциативного массива NativeDictionary воспользуемся хэш-таблицей, реализованной в предыдущем занятии. По сути, потребуется лишь расширить её вторым массивом -- в дополнение к массиву слотов, который будет хранить ключи.
Второй массив по размеру будет таким же, как и первый, а записываются в него значения, соответствующие ключу слота (с таким же индексом).

Главное отличие ассоциативного массива от хэш-таблицы в том, что он обычно не ограничен каким-то фиксированным размером (количеством ключей), и либо исходно под конкретную задачу создаётся с гарантированным запасом по размеру, либо сочетает возможности хэш-таблицы и динамического массива.

Для хранения данных произвольных типов можно применить механизм полиморфизма или типы-генерики, если язык это позволяет.

Если по каким-то причинам реализация с хэш-функциями не подходит (например, возникает слишком много коллизий), то для реализации словаря вполне можно использовать упорядоченный массив фиксированного размера, который хранит, например, объекты с двумя полями ключ и значение.
Другой вариант -- использовать для реализации словаря двоичное сбалансированное дерево, где поиск ключей происходит очень эффективно (все важные виды поиска проходим на курсах по деревьям графам и сортировкам). Но сама реализация будет сложнее, она подразумевает работу с указателями и динамическим выделением памяти, а изменение структуры дерева (добавление новых узлов и балансировка) может требовать дополнительных накладных ресурсов, если, например, счёт идёт на миллионы элементов.

Задания.

1. Выясните, как в языке программирования, которым вы пользуетесь, реализован тип данных Словарь.

2. Реализуйте класс NativeDictionary, как описано выше.

3. Добавьте в этот класс три метода:

- put(key, value) - сохранение внутри класса ассоциативного массива пары ключ-значение по описанной выше схеме;

- is_key(key) - проверка, имеется ли в слотах такой ключ;

- get(key) - поиск и извлечение значения по ключу, или отсутствие значения, если ключ не найден.

4. Сделайте тесты, проверяющие, как работают put(), is_key() и get():
- добавление значения по новому ключу и добавление значения по уже существующему ключу с проверками что записалось,
- проверка присутствующего и отсутствующего ключей,
- извлечение значения по существующему и отсутствующему ключу.