Очереди потому и называются очереди, что они работают как очереди: вход (добавление) происходит в хвост очереди, а выход (удаление) -- из её головы.

FIFO, first-in first-out -- первым пришёл, первым вышел
Очередь очевидно моделируется стандартным в большинстве языков типом данных "список" (или динамический массив), который вы возможно уже задействовали в занятии по стеку, если мы можем добавлять в него элементы в конкретную позицию, в частности, в нулевую -- принимаем её за условный хвост. А удаление из головы (принимаем её за последний элемент) происходит удалением этого последнего элемента.

Задания.

1. В классе Queue нам понадобятся три метода: size() (количество элементов в очереди), enqueue(item) -- добавить элемент в хвост очереди, и dequeue(), которая возвращает элемент из головы очереди, удаляя его.

qu = new Queue()
qu.enqueue(1)
qu.enqueue(2)
qu.enqueue(3)
while (qu.size() > 0)
    qu.dequeue()
2. Оцените меру сложности для операций enqueue() (добавление) и dequeue() (удаление) в данной реализации.

3. Напишите функцию, которая "вращает" очередь по кругу на N элементов.

4. Попробуйте реализовать очередь с помощью двух стеков.